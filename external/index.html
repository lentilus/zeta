<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Zeta Graph</title>
    <style>
      html, body {
        margin: 0;
        width: 100%;
        height: 100%;
      }
      #graph { width: 100vw; height: 100vh; }
    </style>
    <script src="_vendor/force-graph.js"></script>
  </head>

  <body>
    <div id="graph"></div>
    <script>
      const graphData = { nodes: [], links: [] };
      const container = document.getElementById('graph');

      function currentColor() {
        return getComputedStyle(document.body).color;
      }

      // Initialize ForceGraph with text nodes
      const Graph = ForceGraph()(container)
        .width(container.clientWidth)
        .height(container.clientHeight)
        .nodeId('id')
        .graphData(graphData)
        .nodeCanvasObject((node, ctx, globalScale) => {
          const label = node.label || node.id;
          if (!label) return;

          const fontSize = 12 / globalScale;
          ctx.font = `${fontSize}px Sans-Serif`;
          const textWidth = ctx.measureText(label).width;
          const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.4); // Padding

          // Draw background rectangle
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.fillRect(
            node.x - bckgDimensions[0] / 2,
            node.y - bckgDimensions[1] / 2,
            ...bckgDimensions
          );

          // Draw text
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = node.grayed ? 'GrayText' : currentColor();
          ctx.fillText(label, node.x, node.y);

          node.__bckgDimensions = bckgDimensions; // Store for pointer area
        })
        .nodePointerAreaPaint((node, color, ctx) => {
          ctx.fillStyle = color;
          const bckgDimensions = node.__bckgDimensions;
          if (bckgDimensions) {
            ctx.fillRect(
              node.x - bckgDimensions[0] / 2,
              node.y - bckgDimensions[1] / 2,
              ...bckgDimensions
            );
          }
        })
        .linkColor(() => currentColor())
        .onNodeClick(node => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ op:'nodeClick', node:{ id: node.id }}));
          }
        });

      function resizeGraph() {
        Graph.width(container.clientWidth)
             .height(container.clientHeight);
      }

      window.addEventListener('resize', resizeGraph);
      resizeGraph();

      function reheatAndUpdate() {
        Graph.graphData(graphData);
      }

      const ws = new WebSocket(`ws://${location.host}/ws`);
      ws.onmessage = ({ data }) => {
        const msg = JSON.parse(data);
        switch (msg.op) {
          case 'init':
            graphData.nodes = msg.graph.nodes;
            graphData.links = msg.graph.links;
            Graph.graphData(graphData);
            break;
          case 'add':
            if (msg.node) graphData.nodes.push(msg.node);
            if (msg.link) graphData.links.push(msg.link);
            reheatAndUpdate();
            break;
          case 'update':
            if (msg.node) {
              const n = graphData.nodes.find(n => n.id === msg.node.id);
              if (n) Object.assign(n, msg.node);
            }
            break;
          case 'deleteNode':
            if (msg.node) {
              const id = msg.node.id;
              graphData.nodes = graphData.nodes.filter(n => n.id !== id);
              graphData.links = graphData.links.filter(l => {
                const ls = typeof l.source === 'object' ? l.source.id : l.source;
                const lt = typeof l.target === 'object' ? l.target.id : l.target;
                return ls !== id && lt !== id;
              });
              reheatAndUpdate();
            }
            break;
          case 'deleteLink':
            if (msg.link) {
              const { source: s, target: t } = msg.link;
              graphData.links = graphData.links.filter(l => {
                const ls = typeof l.source === 'object' ? l.source.id : l.source;
                const lt = typeof l.target === 'object' ? l.target.id : l.target;
                return !(ls === s && lt === t);
              });
              reheatAndUpdate();
            }
            break;
        }
      };
    </script>
  </body>
</html>
