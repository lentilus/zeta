<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Zeta Graph</title>
    <style>
      html, body {
        margin: 0;
        width: 100%;
        height: 100%;
      }
      #graph { width: 100vw; height: 100vh; }
    </style>
    <script src="_vendor/force-graph.js"></script>
  </head>

  <body>
    <div id="graph"></div>
    <script>
      const graphData = { nodes: [], links: [] };
      const container = document.getElementById('graph');

      // helper to get current text color
      function currentColor() {
        return getComputedStyle(document.body).color;
      }

      // Initialize ForceGraph with full container size
      const Graph = ForceGraph()(container)
        .width(container.clientWidth)
        .height(container.clientHeight)
        .nodeId('id')
        .graphData(graphData)
        .nodeCanvasObject((node, ctx, globalScale) => {
          const r    = 5;
          const fg   = getComputedStyle(document.body).color;
          const bg   = getComputedStyle(document.body).backgroundColor;
          const label = node.label;
          const fontSize = 12 / globalScale;

          // Draw node circle
          ctx.beginPath();
          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI);
          ctx.fillStyle = node.grayed ? 'GrayText' : fg;
          ctx.fill();

          // Draw label with halo
          if (globalScale > 0.8 && label) {
            ctx.font = `${fontSize}px Sans-Serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // measure label
            const metrics = ctx.measureText(label);
            const textW   = metrics.width;
            const textH   = fontSize;
            const pad     = 2; // px around text

            // background box
            ctx.fillStyle = bg;
            ctx.fillRect(
              node.x - textW/2 - pad,
              node.y + r + 2 - pad/2,
              textW + pad*2,
              textH + pad
            );

            // draw text
            ctx.fillStyle   = node.grayed ? 'GrayText' : fg;
            ctx.fillText(label, node.x, node.y + r + 2);
          }
        })
        .linkColor(() => currentColor())
        .onNodeClick(node => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ op:'nodeClick', node:{ id: node.id }}));
          }
        });

      // Handle window resize: update graph dimensions
      function resizeGraph() {
        Graph.width(container.clientWidth)
             .height(container.clientHeight);
      }

      window.addEventListener('resize', resizeGraph);
      resizeGraph();

      // When new data arrives, re-heat the simulation so that colors are re-read
      function reheatAndUpdate() {
        Graph.graphData(graphData);
      }

      const ws = new WebSocket(`ws://${location.host}/ws`);
      ws.onmessage = ({ data }) => {
        const msg = JSON.parse(data);
        switch (msg.op) {
          case 'init':
            graphData.nodes = msg.graph.nodes;
            graphData.links = msg.graph.links;
            Graph.graphData(graphData);
            break;
          case 'add':
            if (msg.node) graphData.nodes.push(msg.node);
            if (msg.link) graphData.links.push(msg.link);
            reheatAndUpdate();
            break;
          case 'update':
            if (msg.node) {
              const n = graphData.nodes.find(n => n.id === msg.node.id);
              if (n) Object.assign(n, msg.node);
              // Graph.refresh();
            }
            break;
          case 'deleteNode':
            if (msg.node) {
              const id = msg.node.id;
              graphData.nodes = graphData.nodes.filter(n => n.id !== id);
              graphData.links = graphData.links.filter(l => {
                const ls = typeof l.source === 'object' ? l.source.id : l.source;
                const lt = typeof l.target === 'object' ? l.target.id : l.target;
                return ls !== id && lt !== id;
              });
              reheatAndUpdate();
            }
            break;
          case 'deleteLink':
            if (msg.link) {
              const { source: s, target: t } = msg.link;
              graphData.links = graphData.links.filter(l => {
                const ls = typeof l.source === 'object' ? l.source.id : l.source;
                const lt = typeof l.target === 'object' ? l.target.id : l.target;
                return !(ls === s && lt === t);
              });
              reheatAndUpdate();
            }
            break;
        }
      };
    </script>
  </body>
</html>
