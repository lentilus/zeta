<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Zeta Graph</title>
    <style> body { margin:0 } #graph { width:100vw; height:100vh } </style>
    <script src="https://cdn.jsdelivr.net/npm/force-graph"></script>
  </head>

  <body>
    <div id="graph"></div>
    <script>
      // 1) Single shared data object
      const graphData = { nodes: [], links: [] };

      // 2) Build Graph once
      const Graph = ForceGraph()(document.getElementById('graph'))
        .nodeId('id')
        .graphData(graphData)
        .d3ReheatSimulation(false)
        .d3AlphaDecay(0.02)
        .d3VelocityDecay(0.2)
        .nodeCanvasObject((node, ctx, globalScale) => {
          const r = 5;
          ctx.beginPath();
          ctx.arc(node.x, node.y, r, 0, 2*Math.PI);
          ctx.fillStyle = '#ccc';
          ctx.fill();
          if (globalScale > 0.8 && node.label) {
            ctx.save();
            ctx.globalAlpha = Math.min(1,(globalScale-0.8)/0.2);
            ctx.font = `${12/globalScale}px Sans-Serif`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.fillText(node.label, node.x, node.y + r + 2);
            ctx.restore();
          }
        })
        .linkColor(() => '#ccc')
        .onNodeClick(node => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ op:'nodeClick', node:{ id: node.id }}));
          }
        });

      // 3) WebSocket handler
      const ws = new WebSocket(`ws://${location.host}/ws`);
      ws.onmessage = ({ data }) => {
        const msg = JSON.parse(data);

        switch (msg.op) {
          case 'init':
            // first time: replace arrays in place
            graphData.nodes = msg.graph.nodes;
            graphData.links = msg.graph.links;
            Graph.graphData(graphData);
            break;

          case 'add':
            if (msg.node) graphData.nodes.push(msg.node);
            if (msg.link) {
              // Option A: let force‑graph auto‑normalize the IDs…
              graphData.links.push(msg.link);
              // Option B: manually turn IDs into objects:
              // const src = graphData.nodes.find(n=>n.id===msg.link.source);
              // const tgt = graphData.nodes.find(n=>n.id===msg.link.target);
              // graphData.links.push({ source: src, target: tgt });
            }
            Graph.graphData(graphData);
            break;

          case 'update':
            if (msg.node) {
              const n = graphData.nodes.find(n=>n.id===msg.node.id);
              if (n) Object.assign(n, msg.node);
              Graph.graphData(graphData);
            }
            break;

          case 'deleteNode':
            if (msg.node) {
              const id = msg.node.id;
              graphData.nodes = graphData.nodes.filter(n=>n.id!==id);
              graphData.links = graphData.links.filter(l=> {
                const ls = typeof l.source==='object'?l.source.id:l.source;
                const lt = typeof l.target==='object'?l.target.id:l.target;
                return ls!==id && lt!==id;
              });
              Graph.graphData(graphData);
            }
            break;

          case 'deleteLink':
            if (msg.link) {
              const { source:s, target:t } = msg.link;
              graphData.links = graphData.links.filter(l=> {
                const ls = typeof l.source==='object'?l.source.id:l.source;
                const lt = typeof l.target==='object'?l.target.id:l.target;
                return !(ls===s && lt===t);
              });
              Graph.graphData(graphData);
            }
            break;
        }
      };
    </script>
  </body>
</html>
